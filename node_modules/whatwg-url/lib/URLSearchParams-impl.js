"use strict";
const urlencoded = require("./urlencoded");

exports.implementation = class URLSearchParamsImpl {
  constructor(globalObject, constructorArgs, { doNotStripQMark = false }) {
    let init = constructorArgs[0];
    this._list = [];
    this._url = null;

    if (!doNotStripQMark && typeof init === "string" && init[0] === "?") {
      init = init.slice(1);
***REMOVED***

    if (Array.isArray(init)) {
      for (const pair of init) {
        if (pair.length !== 2) {
          throw new TypeError("Failed to construct 'URLSearchParams': parameter 1 sequence's element does not " +
                              "contain exactly two elements.");
    ***REMOVED***
        this._list.push([pair[0], pair[1]]);
  ***REMOVED***
***REMOVED*** else if (typeof init === "object" && Object.getPrototypeOf(init) === null) {
      for (const name of Object.keys(init)) {
        const value = init[name];
        this._list.push([name, value]);
  ***REMOVED***
***REMOVED***
      this._list = urlencoded.parseUrlencodedString(init);
***REMOVED***
***REMOVED***

  _updateSteps() {
    if (this._url !== null) {
      let query = urlencoded.serializeUrlencoded(this._list);
      if (query === "") {
        query = null;
  ***REMOVED***
      this._url._url.query = query;
***REMOVED***
***REMOVED***

  append(name, value) {
    this._list.push([name, value]);
    this._updateSteps();
***REMOVED***

  delete(name) {
    let i = 0;
    while (i < this._list.length) {
      if (this._list[i][0] === name) {
        this._list.splice(i, 1);
  ***REMOVED***
        i++;
  ***REMOVED***
***REMOVED***
    this._updateSteps();
***REMOVED***

  get(name) {
    for (const tuple of this._list) {
      if (tuple[0] === name) {
        return tuple[1];
  ***REMOVED***
***REMOVED***
    return null;
***REMOVED***

  getAll(name) {
    const output = [];
    for (const tuple of this._list) {
      if (tuple[0] === name) {
        output.push(tuple[1]);
  ***REMOVED***
***REMOVED***
    return output;
***REMOVED***

  has(name) {
    for (const tuple of this._list) {
      if (tuple[0] === name) {
        return true;
  ***REMOVED***
***REMOVED***
    return false;
***REMOVED***

  set(name, value) {
    let found = false;
    let i = 0;
    while (i < this._list.length) {
      if (this._list[i][0] === name) {
        if (found) {
          this._list.splice(i, 1);
    ***REMOVED***
          found = true;
          this._list[i][1] = value;
          i++;
    ***REMOVED***
  ***REMOVED***
        i++;
  ***REMOVED***
***REMOVED***
    if (!found) {
      this._list.push([name, value]);
***REMOVED***
    this._updateSteps();
***REMOVED***

  sort() {
    this._list.sort((a, b) => {
      if (a[0] < b[0]) {
        return -1;
  ***REMOVED***
      if (a[0] > b[0]) {
        return 1;
  ***REMOVED***
      return 0;
    ***REMOVED***

    this._updateSteps();
***REMOVED***

  [Symbol.iterator]() {
    return this._list[Symbol.iterator]();
***REMOVED***

  toString() {
    return urlencoded.serializeUrlencoded(this._list);
***REMOVED***
};
