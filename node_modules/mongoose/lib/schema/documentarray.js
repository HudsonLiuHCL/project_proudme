'use strict';

/*!
 * Module dependencies.
 */

const ArrayType = require('./array');
const CastError = require('../error/cast');
const EventEmitter = require('events').EventEmitter;
const SchemaDocumentArrayOptions =
  require('../options/SchemaDocumentArrayOptions');
const SchemaType = require('../schematype');
const SubdocumentPath = require('./SubdocumentPath');
const discriminator = require('../helpers/model/discriminator');
const handleIdOption = require('../helpers/schema/handleIdOption');
const handleSpreadDoc = require('../helpers/document/handleSpreadDoc');
const utils = require('../utils');
const getConstructor = require('../helpers/discriminator/getConstructor');

const arrayAtomicsSymbol = require('../helpers/symbols').arrayAtomicsSymbol;
const arrayPathSymbol = require('../helpers/symbols').arrayPathSymbol;
const documentArrayParent = require('../helpers/symbols').documentArrayParent;

let MongooseDocumentArray;
let Subdocument;

/**
 * SubdocsArray SchemaType constructor
 *
 * @param {String} key
 * @param {Schema} schema
 * @param {Object} options
 * @param {Object} schemaOptions
 * @inherits SchemaArray
 * @api public
 */

function DocumentArrayPath(key, schema, options, schemaOptions) {
  const schemaTypeIdOption = DocumentArrayPath.defaultOptions &&
    DocumentArrayPath.defaultOptions._id;
  if (schemaTypeIdOption != null) {
    schemaOptions = schemaOptions || {};
    schemaOptions._id = schemaTypeIdOption;
***REMOVED***

  if (schemaOptions != null && schemaOptions._id != null) {
    schema = handleIdOption(schema, schemaOptions);
***REMOVED*** else if (options != null && options._id != null) {
    schema = handleIdOption(schema, options);
***REMOVED***

  const EmbeddedDocument = _createConstructor(schema, options);
  EmbeddedDocument.prototype.$basePath = key;

  ArrayType.call(this, key, EmbeddedDocument, options);

  this.schema = schema;
  this.schemaOptions = schemaOptions || {};
  this.$isMongooseDocumentArray = true;
  this.Constructor = EmbeddedDocument;

  EmbeddedDocument.base = schema.base;

  const fn = this.defaultValue;

  if (!('defaultValue' in this) || fn !== void 0) {
    this.default(function() {
      let arr = fn.call(this);
      if (arr != null && !Array.isArray(arr)) {
        arr = [arr];
  ***REMOVED***
      // Leave it up to `cast()` to convert this to a documentarray
      return arr;
    ***REMOVED***
***REMOVED***

  const parentSchemaType = this;
  this.$embeddedSchemaType = new SchemaType(key + '.$', {
    required: this &&
      this.schemaOptions &&
      this.schemaOptions.required || false
  ***REMOVED***
  this.$embeddedSchemaType.cast = function(value, doc, init) {
    return parentSchemaType.cast(value, doc, init)[0];
***REMOVED***;
  this.$embeddedSchemaType.doValidate = function(value, fn, scope, options) {
    const Constructor = getConstructor(this.caster, value);

    if (value && !(value instanceof Constructor)) {
      value = new Constructor(value, scope, null, null, options && options.index != null ? options.index : null);
***REMOVED***

    return SubdocumentPath.prototype.doValidate.call(this, value, fn, scope, options);
***REMOVED***;
  this.$embeddedSchemaType.$isMongooseDocumentArrayElement = true;
  this.$embeddedSchemaType.caster = this.Constructor;
  this.$embeddedSchemaType.schema = this.schema;
}

/**
 * This schema type's name, to defend against minifiers that mangle
 * function names.
 *
 * @api public
 */
DocumentArrayPath.schemaName = 'DocumentArray';

/**
 * Options for all document arrays.
 *
 * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.
 *
 * @api public
 */

DocumentArrayPath.options = { castNonArrays: true };

/*!
 * Inherits from ArrayType.
 */
DocumentArrayPath.prototype = Object.create(ArrayType.prototype);
DocumentArrayPath.prototype.constructor = DocumentArrayPath;
DocumentArrayPath.prototype.OptionsConstructor = SchemaDocumentArrayOptions;

/*!
 * ignore
 */

function _createConstructor(schema, options, baseClass) {
  Subdocument || (Subdocument = require('../types/ArraySubdocument'));

  // compile an embedded document for this schema
  function EmbeddedDocument() {
    Subdocument.apply(this, arguments);
    if (this.__parentArray == null || this.__parentArray.getArrayParent() == null) {
      return;
***REMOVED***
    this.$session(this.__parentArray.getArrayParent().$session());
***REMOVED***

  schema._preCompile();

  const proto = baseClass != null ? baseClass.prototype : Subdocument.prototype;
  EmbeddedDocument.prototype = Object.create(proto);
  EmbeddedDocument.prototype.$__setSchema(schema);
  EmbeddedDocument.schema = schema;
  EmbeddedDocument.prototype.constructor = EmbeddedDocument;
  EmbeddedDocument.$isArraySubdocument = true;
  EmbeddedDocument.events = new EventEmitter();
  EmbeddedDocument.base = schema.base;

  // apply methods
  for (const i in schema.methods) {
    EmbeddedDocument.prototype[i] = schema.methods[i];
***REMOVED***

  // apply statics
  for (const i in schema.statics) {
    EmbeddedDocument[i] = schema.statics[i];
***REMOVED***

  for (const i in EventEmitter.prototype) {
    EmbeddedDocument[i] = EventEmitter.prototype[i];
***REMOVED***

  EmbeddedDocument.options = options;

  return EmbeddedDocument;
}

/**
 * Adds a discriminator to this document array.
 *
 * #### Example:
 *
 *     const shapeSchema = Schema({ name: String }, { discriminatorKey: 'kind' ***REMOVED***
 *     const schema = Schema({ shapes: [shapeSchema] ***REMOVED***
 *
 *     const docArrayPath = parentSchema.path('shapes');
 *     docArrayPath.discriminator('Circle', Schema({ radius: Number }));
 *
 * @param {String} name
 * @param {Schema} schema fields to add to the schema for instances of this sub-class
 * @param {Object|string} [options] If string, same as `options.value`.
 * @param {String} [options.value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.
 * @param {Boolean} [options.clone=true] By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.
 * @see discriminators /docs/discriminators.html
 * @return {Function} the constructor Mongoose will use for creating instances of this discriminator model
 * @api public
 */

DocumentArrayPath.prototype.discriminator = function(name, schema, options) {
  if (typeof name === 'function') {
    name = utils.getFunctionName(name);
***REMOVED***

  options = options || {};
  const tiedValue = utils.isPOJO(options) ? options.value : options;
  const clone = typeof options.clone === 'boolean' ? options.clone : true;

  if (schema.instanceOfSchema && clone) {
    schema = schema.clone();
***REMOVED***

  schema = discriminator(this.casterConstructor, name, schema, tiedValue);

  const EmbeddedDocument = _createConstructor(schema, null, this.casterConstructor);
  EmbeddedDocument.baseCasterConstructor = this.casterConstructor;

***REMOVED***
    Object.defineProperty(EmbeddedDocument, 'name', {
      value: name
    ***REMOVED***
***REMOVED***
    // Ignore error, only happens on old versions of node
***REMOVED***

  this.casterConstructor.discriminators[name] = EmbeddedDocument;

  return this.casterConstructor.discriminators[name];
};

/**
 * Performs local validations first, then validations on each embedded doc
 *
 * @api private
 */

DocumentArrayPath.prototype.doValidate = function(array, fn, scope, options) {
  // lazy load
  MongooseDocumentArray || (MongooseDocumentArray = require('../types/DocumentArray'));

  const _this = this;
***REMOVED***
    SchemaType.prototype.doValidate.call(this, array, cb, scope);
***REMOVED*** catch (err) {
    return fn(err);
***REMOVED***

  function cb(err) {
    if (err) {
      return fn(err);
***REMOVED***

    let count = array && array.length;
    let error;

    if (!count) {
      return fn();
***REMOVED***
    if (options && options.updateValidator) {
      return fn();
***REMOVED***
    if (!utils.isMongooseDocumentArray(array)) {
      array = new MongooseDocumentArray(array, _this.path, scope);
***REMOVED***

    // handle sparse arrays, do not use array.forEach which does not
    // iterate over sparse elements yet reports array.length including
    // them :(

    function callback(err) {
      if (err != null) {
        error = err;
  ***REMOVED***
      --count || fn(error);
***REMOVED***

    for (let i = 0, len = count; i < len; ++i) {
      // sidestep sparse entries
      let doc = array[i];
      if (doc == null) {
        --count || fn(error);
        continue;
  ***REMOVED***

      // If you set the array index directly, the doc might not yet be
      // a full fledged mongoose subdoc, so make it into one.
      if (!(doc instanceof Subdocument)) {
        const Constructor = getConstructor(_this.casterConstructor, array[i]);
        doc = array[i] = new Constructor(doc, array, undefined, undefined, i);
  ***REMOVED***

      if (options != null && options.validateModifiedOnly && !doc.$isModified()) {
        --count || fn(error);
        continue;
  ***REMOVED***

      doc.$__validate(callback);
***REMOVED***
***REMOVED***
};

/**
 * Performs local validations first, then validations on each embedded doc.
 *
 * #### Note:
 *
 * This method ignores the asynchronous validators.
 *
 * @return {MongooseError|undefined}
 * @api private
 */

DocumentArrayPath.prototype.doValidateSync = function(array, scope, options) {
  const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, array, scope);
  if (schemaTypeError != null) {
    return schemaTypeError;
***REMOVED***

  const count = array && array.length;
  let resultError = null;

  if (!count) {
    return;
***REMOVED***

  // handle sparse arrays, do not use array.forEach which does not
  // iterate over sparse elements yet reports array.length including
  // them :(

  for (let i = 0, len = count; i < len; ++i) {
    // sidestep sparse entries
    let doc = array[i];
    if (!doc) {
      continue;
***REMOVED***

    // If you set the array index directly, the doc might not yet be
    // a full fledged mongoose subdoc, so make it into one.
    if (!(doc instanceof Subdocument)) {
      const Constructor = getConstructor(this.casterConstructor, array[i]);
      doc = array[i] = new Constructor(doc, array, undefined, undefined, i);
***REMOVED***

    if (options != null && options.validateModifiedOnly && !doc.$isModified()) {
      continue;
***REMOVED***

    const subdocValidateError = doc.validateSync();

    if (subdocValidateError && resultError == null) {
      resultError = subdocValidateError;
***REMOVED***
***REMOVED***

  return resultError;
};

/*!
 * ignore
 */

DocumentArrayPath.prototype.getDefault = function(scope, init, options) {
  let ret = typeof this.defaultValue === 'function'
    ? this.defaultValue.call(scope)
    : this.defaultValue;

  if (ret == null) {
    return ret;
***REMOVED***

  if (options && options.skipCast) {
    return ret;
***REMOVED***

  // lazy load
  MongooseDocumentArray || (MongooseDocumentArray = require('../types/DocumentArray'));

  if (!Array.isArray(ret)) {
    ret = [ret];
***REMOVED***

  ret = new MongooseDocumentArray(ret, this.path, scope);

  for (let i = 0; i < ret.length; ++i) {
    const Constructor = getConstructor(this.casterConstructor, ret[i]);
    const _subdoc = new Constructor({}, ret, undefined,
      undefined, i);
    _subdoc.$init(ret[i]);
    _subdoc.isNew = true;

    // Make sure all paths in the subdoc are set to `default` instead
    // of `init` since we used `init`.
    Object.assign(_subdoc.$__.activePaths.default, _subdoc.$__.activePaths.init);
    _subdoc.$__.activePaths.init = {};

    ret[i] = _subdoc;
***REMOVED***

  return ret;
};

const _toObjectOptions = Object.freeze({ transform: false, virtuals: false ***REMOVED***
const initDocumentOptions = Object.freeze({ skipId: false, willInit: true ***REMOVED***

/**
 * Casts contents
 *
 * @param {Object} value
 * @param {Document} document that triggers the casting
 * @api private
 */

DocumentArrayPath.prototype.cast = function(value, doc, init, prev, options) {
  // lazy load
  MongooseDocumentArray || (MongooseDocumentArray = require('../types/DocumentArray'));

  // Skip casting if `value` is the same as the previous value, no need to cast. See gh-9266
  if (value != null && value[arrayPathSymbol] != null && value === prev) {
    return value;
***REMOVED***

  let selected;
  let subdoc;

  options = options || {};

  if (!Array.isArray(value)) {
    if (!init && !DocumentArrayPath.options.castNonArrays) {
      throw new CastError('DocumentArray', value, this.path, null, this);
***REMOVED***
    // gh-2442 mark whole array as modified if we're initializing a doc from
    // the db and the path isn't an array in the document
    if (!!doc && init) {
      doc.markModified(this.path);
***REMOVED***
    return this.cast([value], doc, init, prev, options);
***REMOVED***

  // We need to create a new array, otherwise change tracking will
  // update the old doc (gh-4449)
  if (!options.skipDocumentArrayCast || utils.isMongooseDocumentArray(value)) {
    value = new MongooseDocumentArray(value, this.path, doc);
***REMOVED***

  if (prev != null) {
    value[arrayAtomicsSymbol] = prev[arrayAtomicsSymbol] || {};
***REMOVED***

  if (options.arrayPathIndex != null) {
    value[arrayPathSymbol] = this.path + '.' + options.arrayPathIndex;
***REMOVED***

  const rawArray = utils.isMongooseDocumentArray(value) ? value.__array : value;
  const len = rawArray.length;

  for (let i = 0; i < len; ++i) {
    if (!rawArray[i]) {
      continue;
***REMOVED***

    const Constructor = getConstructor(this.casterConstructor, rawArray[i]);

    // Check if the document has a different schema (re gh-3701)
    if (rawArray[i].$__ != null && !(rawArray[i] instanceof Constructor)) {
      const spreadDoc = handleSpreadDoc(rawArray[i], true);
      if (rawArray[i] !== spreadDoc) {
        rawArray[i] = spreadDoc;
  ***REMOVED***
        rawArray[i] = rawArray[i].toObject({
          transform: false,
          // Special case: if different model, but same schema, apply virtuals
          // re: gh-7898
          virtuals: rawArray[i].schema === Constructor.schema
        ***REMOVED***
  ***REMOVED***
***REMOVED***

    if (rawArray[i] instanceof Subdocument) {
      if (rawArray[i][documentArrayParent] !== doc) {
        if (init) {
          const subdoc = new Constructor(null, value, initDocumentOptions, selected, i);
          rawArray[i] = subdoc.$init(rawArray[i]);
    ***REMOVED***
          const subdoc = new Constructor(rawArray[i], value, undefined, undefined, i);
          rawArray[i] = subdoc;
    ***REMOVED***
  ***REMOVED***
      // Might not have the correct index yet, so ensure it does.
      if (rawArray[i].__index == null) {
        rawArray[i].$setIndex(i);
  ***REMOVED***
***REMOVED*** else if (rawArray[i] != null) {
      if (init) {
        if (doc) {
          selected || (selected = scopePaths(this, doc.$__.selected, init));
    ***REMOVED***
          selected = true;
    ***REMOVED***

        subdoc = new Constructor(null, value, initDocumentOptions, selected, i);
        rawArray[i] = subdoc.$init(rawArray[i]);
  ***REMOVED***
        if (prev && typeof prev.id === 'function') {
          subdoc = prev.id(rawArray[i]._id);
    ***REMOVED***

        if (prev && subdoc && utils.deepEqual(subdoc.toObject(_toObjectOptions), rawArray[i])) {
          // handle resetting doc with existing id and same data
          subdoc.set(rawArray[i]);
          // if set() is hooked it will have no return value
          // see gh-746
          rawArray[i] = subdoc;
    ***REMOVED***
        ***REMOVED***
            subdoc = new Constructor(rawArray[i], value, undefined,
              undefined, i);
            // if set() is hooked it will have no return value
            // see gh-746
            rawArray[i] = subdoc;
      ***REMOVED*** catch (error) {
            throw new CastError('embedded', rawArray[i],
              value[arrayPathSymbol], error, this);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***
***REMOVED***

  return value;
};

/*!
 * ignore
 */

DocumentArrayPath.prototype.clone = function() {
  const options = Object.assign({}, this.options);
  const schematype = new this.constructor(this.path, this.schema, options, this.schemaOptions);
  schematype.validators = this.validators.slice();
  if (this.requiredValidator !== undefined) {
    schematype.requiredValidator = this.requiredValidator;
***REMOVED***
  schematype.Constructor.discriminators = Object.assign({},
    this.Constructor.discriminators);
  return schematype;
};

/*!
 * ignore
 */

DocumentArrayPath.prototype.applyGetters = function(value, scope) {
  return SchemaType.prototype.applyGetters.call(this, value, scope);
};

/**
 * Scopes paths selected in a query to this array.
 * Necessary for proper default application of subdocument values.
 *
 * @param {DocumentArrayPath} array the array to scope `fields` paths
 * @param {Object|undefined} fields the root fields selected in the query
 * @param {Boolean|undefined} init if we are being created part of a query result
 * @api private
 */

function scopePaths(array, fields, init) {
  if (!(init && fields)) {
    return undefined;
***REMOVED***

  const path = array.path + '.';
  const keys = Object.keys(fields);
  let i = keys.length;
  const selected = {};
  let hasKeys;
  let key;
  let sub;

  while (i--) {
    key = keys[i];
    if (key.startsWith(path)) {
      sub = key.substring(path.length);
      if (sub === '$') {
        continue;
  ***REMOVED***
      if (sub.startsWith('$.')) {
        sub = sub.substring(2);
  ***REMOVED***
      hasKeys || (hasKeys = true);
      selected[sub] = fields[key];
***REMOVED***
***REMOVED***

  return hasKeys && selected || undefined;
}

/*!
 * ignore
 */

DocumentArrayPath.defaultOptions = {};

/**
 * Sets a default option for all DocumentArray instances.
 *
 * #### Example:
 *
 *     // Make all numbers have option `min` equal to 0.
 *     mongoose.Schema.DocumentArray.set('_id', false);
 *
 * @param {String} option The name of the option you'd like to set (e.g. trim, lowercase, etc...)
 * @param {Any} value The value of the option you'd like to set.
 * @return {void}
 * @function set
 * @static
 * @api public
 */

DocumentArrayPath.set = SchemaType.set;

/*!
 * Module exports.
 */

module.exports = DocumentArrayPath;
