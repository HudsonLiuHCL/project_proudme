'use strict';

module.exports = function applyDefaults(doc, fields, exclude, hasIncludedChildren, isBeforeSetters, pathsToSkip) {
  const paths = Object.keys(doc.$__schema.paths);
  const plen = paths.length;

  for (let i = 0; i < plen; ++i) {
    let def;
    let curPath = '';
    const p = paths[i];

    if (p === '_id' && doc.$__.skipId) {
      continue;
***REMOVED***

    const type = doc.$__schema.paths[p];
    const path = type.splitPath();
    const len = path.length;
    let included = false;
    let doc_ = doc._doc;
    for (let j = 0; j < len; ++j) {
      if (doc_ == null) {
        break;
  ***REMOVED***

      const piece = path[j];
      curPath += (!curPath.length ? '' : '.') + piece;

      if (exclude === true) {
        if (curPath in fields) {
          break;
    ***REMOVED***
  ***REMOVED*** else if (exclude === false && fields && !included) {
        const hasSubpaths = type.$isSingleNested || type.$isMongooseDocumentArray;
        if (curPath in fields || (hasSubpaths && hasIncludedChildren != null && hasIncludedChildren[curPath])) {
          included = true;
    ***REMOVED*** else if (hasIncludedChildren != null && !hasIncludedChildren[curPath]) {
          break;
    ***REMOVED***
  ***REMOVED***

      if (j === len - 1) {
        if (doc_[piece] !== void 0) {
          break;
    ***REMOVED***

        if (isBeforeSetters != null) {
          if (typeof type.defaultValue === 'function') {
            if (!type.defaultValue.$runBeforeSetters && isBeforeSetters) {
              break;
        ***REMOVED***
            if (type.defaultValue.$runBeforeSetters && !isBeforeSetters) {
              break;
        ***REMOVED***
      ***REMOVED*** else if (!isBeforeSetters) {
            // Non-function defaults should always run **before** setters
            continue;
      ***REMOVED***
    ***REMOVED***

        if (pathsToSkip && pathsToSkip[curPath]) {
          break;
    ***REMOVED***

        if (fields && exclude !== null) {
          if (exclude === true) {
            // apply defaults to all non-excluded fields
            if (p in fields) {
              continue;
        ***REMOVED***

          ***REMOVED***
              def = type.getDefault(doc, false);
        ***REMOVED*** catch (err) {
              doc.invalidate(p, err);
              break;
        ***REMOVED***

            if (typeof def !== 'undefined') {
              doc_[piece] = def;
              applyChangeTracking(doc, p);
        ***REMOVED***
      ***REMOVED*** else if (included) {
            // selected field
          ***REMOVED***
              def = type.getDefault(doc, false);
        ***REMOVED*** catch (err) {
              doc.invalidate(p, err);
              break;
        ***REMOVED***

            if (typeof def !== 'undefined') {
              doc_[piece] = def;
              applyChangeTracking(doc, p);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
        ***REMOVED***
            def = type.getDefault(doc, false);
      ***REMOVED*** catch (err) {
            doc.invalidate(p, err);
            break;
      ***REMOVED***

          if (typeof def !== 'undefined') {
            doc_[piece] = def;
            applyChangeTracking(doc, p);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
        doc_ = doc_[piece];
  ***REMOVED***
***REMOVED***
***REMOVED***
};

/*!
 * ignore
 */

function applyChangeTracking(doc, fullPath) {
  doc.$__.activePaths.default(fullPath);
  if (doc.$isSubdocument && doc.$isSingleNested && doc.$parent() != null) {
    doc.$parent().$__.activePaths.default(doc.$__pathRelativeToParent(fullPath));
***REMOVED***
}
