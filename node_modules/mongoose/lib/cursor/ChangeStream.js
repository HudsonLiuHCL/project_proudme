'use strict';

/*!
 * Module dependencies.
 */

const EventEmitter = require('events').EventEmitter;

/*!
 * ignore
 */

class ChangeStream extends EventEmitter {
  constructor(changeStreamThunk, pipeline, options) {
    super();

    this.driverChangeStream = null;
    this.closed = false;
    this.bindedEvents = false;
    this.pipeline = pipeline;
    this.options = options;

    if (options && options.hydrate && !options.model) {
      throw new Error(
        'Cannot create change stream with `hydrate: true` ' +
        'unless calling `Model.watch()`'
      );
***REMOVED***

    // This wrapper is necessary because of buffering.
    changeStreamThunk((err, driverChangeStream) => {
      if (err != null) {
        this.emit('error', err);
        return;
  ***REMOVED***

      this.driverChangeStream = driverChangeStream;
      this.emit('ready');
    ***REMOVED***
***REMOVED***

  _bindEvents() {
    if (this.bindedEvents) {
      return;
***REMOVED***

    this.bindedEvents = true;

    if (this.driverChangeStream == null) {
      this.once('ready', () => {
        this.driverChangeStream.on('close', () => {
          this.closed = true;
        ***REMOVED***

        ['close', 'change', 'end', 'error'].forEach(ev => {
          this.driverChangeStream.on(ev, data => {
            // Sometimes Node driver still polls after close, so
            // avoid any uncaught exceptions due to closed change streams
            // See tests for gh-7022
            if (ev === 'error' && this.closed) {
              return;
        ***REMOVED***
            if (data != null && data.fullDocument != null && this.options && this.options.hydrate) {
              data.fullDocument = this.options.model.hydrate(data.fullDocument);
        ***REMOVED***
            this.emit(ev, data);
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***

      return;
***REMOVED***

    this.driverChangeStream.on('close', () => {
      this.closed = true;
    ***REMOVED***

    ['close', 'change', 'end', 'error'].forEach(ev => {
      this.driverChangeStream.on(ev, data => {
        // Sometimes Node driver still polls after close, so
        // avoid any uncaught exceptions due to closed change streams
        // See tests for gh-7022
        if (ev === 'error' && this.closed) {
          return;
    ***REMOVED***
        this.emit(ev, data);
      ***REMOVED***
    ***REMOVED***
***REMOVED***

  hasNext(cb) {
    return this.driverChangeStream.hasNext(cb);
***REMOVED***

  next(cb) {
    if (this.options && this.options.hydrate) {
      if (cb != null) {
        const originalCb = cb;
        cb = (err, data) => {
          if (err != null) {
            return originalCb(err);
      ***REMOVED***
          if (data.fullDocument != null) {
            data.fullDocument = this.options.model.hydrate(data.fullDocument);
      ***REMOVED***
          return originalCb(null, data);
    ***REMOVED***;
  ***REMOVED***

      let maybePromise = this.driverChangeStream.next(cb);
      if (maybePromise && typeof maybePromise.then === 'function') {
        maybePromise = maybePromise.then(data => {
          if (data.fullDocument != null) {
            data.fullDocument = this.options.model.hydrate(data.fullDocument);
      ***REMOVED***
          return data;
        ***REMOVED***
  ***REMOVED***
      return maybePromise;
***REMOVED***

    return this.driverChangeStream.next(cb);
***REMOVED***

  on(event, handler) {
    this._bindEvents();
    return super.on(event, handler);
***REMOVED***

  once(event, handler) {
    this._bindEvents();
    return super.once(event, handler);
***REMOVED***

  _queue(cb) {
    this.once('ready', () => cb());
***REMOVED***

  close() {
    this.closed = true;
    if (this.driverChangeStream) {
      this.driverChangeStream.close();
***REMOVED***
***REMOVED***
}

/*!
 * ignore
 */

module.exports = ChangeStream;
