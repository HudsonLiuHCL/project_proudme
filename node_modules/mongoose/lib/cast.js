'use strict';

/*!
 * Module dependencies.
 */

const CastError = require('./error/cast');
const StrictModeError = require('./error/strict');
const Types = require('./schema/index');
const cast$expr = require('./helpers/query/cast$expr');
const castTextSearch = require('./schema/operators/text');
const get = require('./helpers/get');
const getConstructorName = require('./helpers/getConstructorName');
const getSchemaDiscriminatorByValue = require('./helpers/discriminator/getSchemaDiscriminatorByValue');
const isOperator = require('./helpers/query/isOperator');
const util = require('util');
const isObject = require('./helpers/isObject');
const isMongooseObject = require('./helpers/isMongooseObject');

const ALLOWED_GEOWITHIN_GEOJSON_TYPES = ['Polygon', 'MultiPolygon'];

/**
 * Handles internal casting for query filters.
 *
 * @param {Schema} schema
 * @param {Object} obj Object to cast
 * @param {Object} [options] the query options
 * @param {Boolean|"throw"} [options.strict] Wheter to enable all strict options
 * @param {Boolean|"throw"} [options.strictQuery] Enable strict Queries
 * @param {Boolean} [options.upsert]
 * @param {Query} [context] passed to setters
 * @api private
 */
module.exports = function cast(schema, obj, options, context) {
  if (Array.isArray(obj)) {
    throw new Error('Query filter must be an object, got an array ', util.inspect(obj));
***REMOVED***

  if (obj == null) {
    return obj;
***REMOVED***

  if (schema != null && schema.discriminators != null && obj[schema.options.discriminatorKey] != null) {
    schema = getSchemaDiscriminatorByValue(schema, obj[schema.options.discriminatorKey]) || schema;
***REMOVED***

  const paths = Object.keys(obj);
  let i = paths.length;
  let _keys;
  let any$conditionals;
  let schematype;
  let nested;
  let path;
  let type;
  let val;

  options = options || {};

  while (i--) {
    path = paths[i];
    val = obj[path];

    if (path === '$or' || path === '$nor' || path === '$and') {
      if (!Array.isArray(val)) {
        throw new CastError('Array', val, path);
  ***REMOVED***
      for (let k = val.length - 1; k >= 0; k--) {
        if (val[k] == null || typeof val[k] !== 'object') {
          throw new CastError('Object', val[k], path + '.' + k);
    ***REMOVED***
        val[k] = cast(schema, val[k], options, context);
        if (Object.keys(val[k]).length === 0) {
          val.splice(k, 1);
    ***REMOVED***
  ***REMOVED***

      if (val.length === 0) {
        delete obj[path];
  ***REMOVED***
***REMOVED*** else if (path === '$where') {
      type = typeof val;

      if (type !== 'string' && type !== 'function') {
        throw new Error('Must have a string or function for $where');
  ***REMOVED***

      if (type === 'function') {
        obj[path] = val.toString();
  ***REMOVED***

      continue;
***REMOVED*** else if (path === '$expr') {
      val = cast$expr(val, schema);
      continue;
***REMOVED*** else if (path === '$elemMatch') {
      val = cast(schema, val, options, context);
***REMOVED*** else if (path === '$text') {
      val = castTextSearch(val, path);
***REMOVED***
      if (!schema) {
        // no casting for Mixed types
        continue;
  ***REMOVED***

      schematype = schema.path(path);

      // Check for embedded discriminator paths
      if (!schematype) {
        const split = path.split('.');
        let j = split.length;
        while (j--) {
          const pathFirstHalf = split.slice(0, j).join('.');
          const pathLastHalf = split.slice(j).join('.');
          const _schematype = schema.path(pathFirstHalf);
          const discriminatorKey = _schematype &&
            _schematype.schema &&
            _schematype.schema.options &&
            _schematype.schema.options.discriminatorKey;

          // gh-6027: if we haven't found the schematype but this path is
          // underneath an embedded discriminator and the embedded discriminator
          // key is in the query, use the embedded discriminator schema
          if (_schematype != null &&
            (_schematype.schema && _schematype.schema.discriminators) != null &&
            discriminatorKey != null &&
            pathLastHalf !== discriminatorKey) {
            const discriminatorVal = get(obj, pathFirstHalf + '.' + discriminatorKey);
            if (discriminatorVal != null) {
              schematype = _schematype.schema.discriminators[discriminatorVal].
                path(pathLastHalf);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

      if (!schematype) {
        // Handle potential embedded array queries
        const split = path.split('.');
        let j = split.length;
        let pathFirstHalf;
        let pathLastHalf;
        let remainingConds;

        // Find the part of the var path that is a path of the Schema
        while (j--) {
          pathFirstHalf = split.slice(0, j).join('.');
          schematype = schema.path(pathFirstHalf);
          if (schematype) {
            break;
      ***REMOVED***
    ***REMOVED***

        // If a substring of the input path resolves to an actual real path...
        if (schematype) {
          // Apply the casting; similar code for $elemMatch in schema/array.js
          if (schematype.caster && schematype.caster.schema) {
            remainingConds = {};
            pathLastHalf = split.slice(j).join('.');
            remainingConds[pathLastHalf] = val;

            const ret = cast(schematype.caster.schema, remainingConds, options, context)[pathLastHalf];
            if (ret === void 0) {
              delete obj[path];
        ***REMOVED***
              obj[path] = ret;
        ***REMOVED***
      ***REMOVED***
            obj[path] = val;
      ***REMOVED***
          continue;
    ***REMOVED***

        if (isObject(val)) {
          // handle geo schemas that use object notation
          // { loc: { long: Number, lat: Number }

          let geo = '';
          if (val.$near) {
            geo = '$near';
      ***REMOVED*** else if (val.$nearSphere) {
            geo = '$nearSphere';
      ***REMOVED*** else if (val.$within) {
            geo = '$within';
      ***REMOVED*** else if (val.$geoIntersects) {
            geo = '$geoIntersects';
      ***REMOVED*** else if (val.$geoWithin) {
            geo = '$geoWithin';
      ***REMOVED***

          if (geo) {
            const numbertype = new Types.Number('__QueryCasting__');
            let value = val[geo];

            if (val.$maxDistance != null) {
              val.$maxDistance = numbertype.castForQueryWrapper({
                val: val.$maxDistance,
                context: context
              ***REMOVED***
        ***REMOVED***
            if (val.$minDistance != null) {
              val.$minDistance = numbertype.castForQueryWrapper({
                val: val.$minDistance,
                context: context
              ***REMOVED***
        ***REMOVED***

            if (geo === '$within') {
              const withinType = value.$center
                  || value.$centerSphere
                  || value.$box
                  || value.$polygon;

              if (!withinType) {
                throw new Error('Bad $within parameter: ' + JSON.stringify(val));
          ***REMOVED***

              value = withinType;
        ***REMOVED*** else if (geo === '$near' &&
                typeof value.type === 'string' && Array.isArray(value.coordinates)) {
              // geojson; cast the coordinates
              value = value.coordinates;
        ***REMOVED*** else if ((geo === '$near' || geo === '$nearSphere' || geo === '$geoIntersects') &&
                value.$geometry && typeof value.$geometry.type === 'string' &&
                Array.isArray(value.$geometry.coordinates)) {
              if (value.$maxDistance != null) {
                value.$maxDistance = numbertype.castForQueryWrapper({
                  val: value.$maxDistance,
                  context: context
                ***REMOVED***
          ***REMOVED***
              if (value.$minDistance != null) {
                value.$minDistance = numbertype.castForQueryWrapper({
                  val: value.$minDistance,
                  context: context
                ***REMOVED***
          ***REMOVED***
              if (isMongooseObject(value.$geometry)) {
                value.$geometry = value.$geometry.toObject({
                  transform: false,
                  virtuals: false
                ***REMOVED***
          ***REMOVED***
              value = value.$geometry.coordinates;
        ***REMOVED*** else if (geo === '$geoWithin') {
              if (value.$geometry) {
                if (isMongooseObject(value.$geometry)) {
                  value.$geometry = value.$geometry.toObject({ virtuals: false ***REMOVED***
            ***REMOVED***
                const geoWithinType = value.$geometry.type;
                if (ALLOWED_GEOWITHIN_GEOJSON_TYPES.indexOf(geoWithinType) === -1) {
                  throw new Error('Invalid geoJSON type for $geoWithin "' +
                    geoWithinType + '", must be "Polygon" or "MultiPolygon"');
            ***REMOVED***
                value = value.$geometry.coordinates;
          ***REMOVED***
                value = value.$box || value.$polygon || value.$center ||
                  value.$centerSphere;
                if (isMongooseObject(value)) {
                  value = value.toObject({ virtuals: false ***REMOVED***
            ***REMOVED***
          ***REMOVED***
        ***REMOVED***

            _cast(value, numbertype, context);
            continue;
      ***REMOVED***
    ***REMOVED***

        if (schema.nested[path]) {
          continue;
    ***REMOVED***

        const strict = 'strict' in options ? options.strict : schema.options.strict;
        const strictQuery = getStrictQuery(options, schema._userProvidedOptions, schema.options, context);
        if (options.upsert && strict) {
          if (strict === 'throw') {
            throw new StrictModeError(path);
      ***REMOVED***
          throw new StrictModeError(path, 'Path "' + path + '" is not in ' +
            'schema, strict mode is `true`, and upsert is `true`.');
    ***REMOVED*** if (strictQuery === 'throw') {
          throw new StrictModeError(path, 'Path "' + path + '" is not in ' +
            'schema and strictQuery is \'throw\'.');
    ***REMOVED*** else if (strictQuery) {
          delete obj[path];
    ***REMOVED***
  ***REMOVED*** else if (val == null) {
        continue;
  ***REMOVED*** else if (getConstructorName(val) === 'Object') {
        any$conditionals = Object.keys(val).some(isOperator);

        if (!any$conditionals) {
          obj[path] = schematype.castForQueryWrapper({
            val: val,
            context: context
          ***REMOVED***
    ***REMOVED***
          const ks = Object.keys(val);
          let $cond;

          let k = ks.length;

          while (k--) {
            $cond = ks[k];
            nested = val[$cond];

            if ($cond === '$not') {
              if (nested && schematype) {
                _keys = Object.keys(nested);
                if (_keys.length && isOperator(_keys[0])) {
                  for (const key in nested) {
                    nested[key] = schematype.castForQueryWrapper({
                      $conditional: key,
                      val: nested[key],
                      context: context
                    ***REMOVED***
              ***REMOVED***
            ***REMOVED***
                  val[$cond] = schematype.castForQueryWrapper({
                    $conditional: $cond,
                    val: nested,
                    context: context
                  ***REMOVED***
            ***REMOVED***
                continue;
          ***REMOVED***
        ***REMOVED***
              val[$cond] = schematype.castForQueryWrapper({
                $conditional: $cond,
                val: nested,
                context: context
              ***REMOVED***
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED*** else if (Array.isArray(val) && ['Buffer', 'Array'].indexOf(schematype.instance) === -1) {
        const casted = [];
        const valuesArray = val;

        for (const _val of valuesArray) {
          casted.push(schematype.castForQueryWrapper({
            val: _val,
            context: context
      ***REMOVED***));
    ***REMOVED***

        obj[path] = { $in: casted };
  ***REMOVED***
        obj[path] = schematype.castForQueryWrapper({
          val: val,
          context: context
        ***REMOVED***
  ***REMOVED***
***REMOVED***
***REMOVED***

  return obj;
};

function _cast(val, numbertype, context) {
  if (Array.isArray(val)) {
    val.forEach(function(item, i) {
      if (Array.isArray(item) || isObject(item)) {
        return _cast(item, numbertype, context);
  ***REMOVED***
      val[i] = numbertype.castForQueryWrapper({ val: item, context: context ***REMOVED***
    ***REMOVED***
***REMOVED*** else {
    const nearKeys = Object.keys(val);
    let nearLen = nearKeys.length;
    while (nearLen--) {
      const nkey = nearKeys[nearLen];
      const item = val[nkey];
      if (Array.isArray(item) || isObject(item)) {
        _cast(item, numbertype, context);
        val[nkey] = item;
  ***REMOVED***
        val[nkey] = numbertype.castForQuery({ val: item, context: context ***REMOVED***
  ***REMOVED***
***REMOVED***
***REMOVED***
}

function getStrictQuery(queryOptions, schemaUserProvidedOptions, schemaOptions, context) {
  if ('strictQuery' in queryOptions) {
    return queryOptions.strictQuery;
***REMOVED***
  if ('strict' in queryOptions) {
    return queryOptions.strict;
***REMOVED***
  if ('strictQuery' in schemaUserProvidedOptions) {
    return schemaUserProvidedOptions.strictQuery;
***REMOVED***
  if ('strict' in schemaUserProvidedOptions) {
    return schemaUserProvidedOptions.strict;
***REMOVED***
  const mongooseOptions = context &&
    context.mongooseCollection &&
    context.mongooseCollection.conn &&
    context.mongooseCollection.conn.base &&
    context.mongooseCollection.conn.base.options;
  if (mongooseOptions) {
    if ('strictQuery' in mongooseOptions) {
      return mongooseOptions.strictQuery;
***REMOVED***
    if ('strict' in mongooseOptions) {
      return mongooseOptions.strict;
***REMOVED***
***REMOVED***
  return schemaOptions.strictQuery;
}
